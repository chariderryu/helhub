#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
record_voicy.py  (Seleniumクリック版 + TSV + バッチ + ffmpeg録音 + 任意のサイレンス分割)
Windows 11 / Python 3.9+
... (truncated in docstring for brevity in this cell)
"""
import argparse, csv, os, re, subprocess, sys, time
from typing import Dict, List, Optional, Tuple

EDGE_DEFAULT = r"msedge"
CHROME_DEFAULT = r"chrome"
FFMPEG_DEFAULT = r"ffmpeg.exe"
DEVICE_DEFAULT = r'audio="CABLE Output (VB-Audio Virtual Cable)"'

def norm_key(s: str) -> str:
    import re as _re
    return _re.sub(r"\s+", "", s.strip().lower())

def parse_duration_to_seconds(text: str) -> int:
    t = str(text).strip()
    if not t:
        raise ValueError("duration が空です")
    if t.isdigit():
        return int(t)
    parts = t.split(":")
    if len(parts) == 2:
        m, s = parts
        return int(m) * 60 + int(s)
    if len(parts) == 3:
        h, m, s = parts
        return int(h) * 3600 + int(m) * 60 + int(s)
    raise ValueError("対応外のduration形式: " + text)

def sanitize_filename(name: str, maxlen: int = 80) -> str:
    invalid = r'<>:"/\\|?*'
    for ch in invalid:
        name = name.replace(ch, "_")
    import re as _re
    name = _re.sub(r"\s+", " ", name).strip()
    return name[:maxlen]

def guess_number_from_title(title: str) -> Optional[int]:
    import re as _re
    m = _re.match(r"^\s*#\s*(\d+)", title or "", flags=_re.IGNORECASE)
    return int(m.group(1)) if m else None

def load_tsv(path: str, encoding: str = "utf-8") -> List[Dict[str, str]]:
    rows: List[Dict[str, str]] = []
    with open(path, "r", encoding=encoding, newline="") as f:
        reader = csv.DictReader(f, delimiter="\t")
        for r in reader:
            if any(v for v in r.values()) and not str(list(r.values())[0]).lstrip().startswith("#"):
                rows.append({k: (v or "").strip() for k, v in r.items()})
    return rows

def pick_field(row: Dict[str, str], candidates: List[str]) -> Optional[str]:
    mapping = {norm_key(k): k for k in row.keys()}
    for c in candidates:
        key = mapping.get(norm_key(c))
        if key and row.get(key):
            return row[key].strip()
    return None

def extract_fields(row: Dict[str, str]):
    title = pick_field(row, ["タイトル", "title"]) or ""
    url = pick_field(row, ["再生", "url", "URL", "リンク"])
    if not url:
        raise ValueError("URL/再生 フィールドが見つかりません。")
    duration_text = pick_field(row, ["duration", "長さ", "再生時間", "再生時間(分)", "time", "length", "duration_sec"])
    explicit_out = pick_field(row, ["out_mp3", "出力", "ファイル名"])
    num_text = pick_field(row, ["number", "No", "通し番号"])
    number = int(num_text) if (num_text and str(num_text).isdigit()) else guess_number_from_title(title)
    return number, title, url, duration_text, explicit_out

def build_out_path(out_dir: Optional[str], number: Optional[int], title: str, explicit: Optional[str]) -> str:
    if explicit: return explicit
    stem = f"heldio_{number:04d}" if number is not None else sanitize_filename(title or "heldio")
    if out_dir:
        os.makedirs(out_dir, exist_ok=True)
        return os.path.join(out_dir, f"{stem}.mp3")
    return f"{stem}.mp3"

def select_rows(rows, number, range_spec, title_regex):
    import re as _re
    rx = _re.compile(title_regex, _re.IGNORECASE) if title_regex else _re.compile(r'^\s*#\s*\d+', _re.IGNORECASE)
    filtered = [r for r in rows if rx.search(pick_field(r, ["タイトル", "title"]) or "")]
    if number is not None or range_spec:
        res = []
        start = end = None
        if range_spec:
            m = _re.match(r"^\s*(\d+)\s*-\s*(\d+)\s*$", range_spec)
            if not m: raise ValueError("--range は 431-440 の形式で指定してください。")
            start, end = int(m.group(1)), int(m.group(2))
            if start > end: start, end = end, start
        for r in filtered:
            n, title, url, dur, explicit = extract_fields(r)
            if number is not None:
                if n == number: res.append(r)
            else:
                if n is not None and start <= n <= end: res.append(r)
        return res
    return filtered

def open_and_start_play(url, browser="chrome", driver_path=None, click_timeout=10.0, autoplay_policy=True):
    from selenium import webdriver
    from selenium.webdriver.common.by import By
    from selenium.webdriver.common.keys import Keys
    from selenium.webdriver.support.ui import WebDriverWait
    from selenium.webdriver.support import expected_conditions as EC

    if browser.lower() == "edge":
        from selenium.webdriver.edge.options import Options as EdgeOptions
        opts = EdgeOptions(); opts.add_argument(f"--app={url}")
        if autoplay_policy: opts.add_argument("--autoplay-policy=no-user-gesture-required")
        driver = webdriver.Edge(executable_path=driver_path, options=opts) if driver_path else webdriver.Edge(options=opts)
    else:
        from selenium.webdriver.chrome.options import Options as ChromeOptions
        opts = ChromeOptions(); opts.add_argument(f"--app={url}")
        if autoplay_policy: opts.add_argument("--autoplay-policy=no-user-gesture-required")
        driver = webdriver.Chrome(executable_path=driver_path, options=opts) if driver_path else webdriver.Chrome(options=opts)

    wait = WebDriverWait(driver, click_timeout)

    def safe_click_cookie():
        try:
            for xp in [
                "//button[contains(., '同意') or contains(., '同意する') or contains(., 'Accept')]",
                "//div[contains(., 'Cookie')]/following::button[1]",
            ]:
                btns = driver.find_elements(By.XPATH, xp)
                for btn in btns:
                    try: btn.click(); time.sleep(0.2); return
                    except: pass
        except: pass

    def try_click_play_button():
        selectors = [
            (By.XPATH, "//button[contains(@aria-label, '再生') or contains(., '再生')]"),
            (By.XPATH, "//button[contains(@data-testid, 'play')]"),
            (By.CSS_SELECTOR, "button[aria-label*='再生']"),
            (By.XPATH, "//button//*[name()='svg' and contains(@aria-label,'play')]/ancestor::button[1]"),
        ]
        for by, sel in selectors:
            try:
                el = wait.until(EC.element_to_be_clickable((by, sel)))
                el.click(); return True
            except: continue
        return False

    def try_js_play():
        try:
            driver.execute_script("""
                let played = 0;
                const media = [...document.querySelectorAll('audio,video')];
                for (const m of media) { try { m.muted=false; const p = m.play(); if (p) { p.catch(()=>{}); } played++; } catch(e){} }
                return media.length;
            """); return True
        except: return False

    def try_keys():
        try:
            body = driver.find_element(By.TAG_NAME, "body")
            body.send_keys(Keys.SPACE); time.sleep(0.3); body.send_keys("k"); return True
        except: return False

    time.sleep(1.0); safe_click_cookie()
    if not try_click_play_button():
        if not try_js_play():
            try_keys()
    return driver

def run_ffmpeg_record(device_name, out_mp3, duration_sec, ffmpeg_path, samplerate=48000, bitrate="192k"):
    args = [ffmpeg_path, "-y", "-f", "dshow", "-i", device_name, "-ac", "2", "-ar", str(samplerate),
            "-t", str(int(duration_sec)), "-c:a", "libmp3lame", "-b:a", bitrate, out_mp3]
    print("[ffmpeg] " + " ".join(args))
    return subprocess.run(args).returncode

def close_driver_quiet(driver):
    try: driver.quit()
    except: pass

def split_on_silence_postproc(in_mp3, out_prefix, min_silence, pad, thresh, bitrate, min_audio, merge_gap):
    try:
        from pydub import AudioSegment
        from pydub.silence import detect_silence
        import numpy as np  # noqa
    except Exception as e:
        print("[warn] pydub/numpy 未導入のため分割をスキップします:", e); return 0
    audio = AudioSegment.from_file(in_mp3)
    dur_ms = len(audio)
    ms = int(max(0.0, min_silence) * 1000)
    pad_ms = int(max(0.0, pad) * 1000)
    min_audio_ms = int(max(0.0, min_audio) * 1000)
    merge_gap_ms = int(max(0.0, merge_gap) * 1000)
    if thresh is None:
        est = audio.dBFS + 4.0; silence_thresh = max(min(est, -18.0), -40.0)
        print(f"[split] auto threshold ≈ {silence_thresh:.1f} dBFS")
    else:
        silence_thresh = float(thresh); print(f"[split] threshold = {silence_thresh:.1f} dBFS")
    silent_ranges = detect_silence(audio, min_silence_len=ms, silence_thresh=silence_thresh)
    if silent_ranges:
        silent_ranges.sort(); merged = [list(silent_ranges[0])]
        for s, e in silent_ranges[1:]:
            if s - merged[-1][1] <= merge_gap_ms: merged[-1][1] = max(merged[-1][1], e)
            else: merged.append([s, e])
        silent_ranges = [tuple(x) for x in merged]
    segments = []; cursor = 0
    for s, e in silent_ranges:
        if s - cursor >= min_audio_ms:
            start = max(0, cursor - pad_ms); end = min(dur_ms, s + pad_ms)
            if end > start: segments.append((start, end))
        cursor = e
    if dur_ms - cursor >= min_audio_ms:
        start = max(0, cursor - pad_ms); end = dur_ms
        if end > start: segments.append((start, end))
    if not segments:
        print("[split] 対象となる無音が見つからず、分割しません。"); return 0
    if out_prefix is None:
        stem, _ = os.path.splitext(in_mp3); out_prefix = stem
    base_dir = os.path.dirname(out_prefix)
    if base_dir and not os.path.exists(base_dir): os.makedirs(base_dir, exist_ok=True)
    count = 0
    for i, (s, e) in enumerate(segments, start=1):
        chunk = audio[s:e]; out_path = f"{out_prefix}_{i:02d}.mp3"
        chunk.export(out_path, format="mp3", bitrate=bitrate)
        print(f"[split] wrote: {out_path}  [{s/1000:.2f}s → {e/1000:.2f}s]"); count += 1
    return count

def process_one(url, duration_sec, out_mp3, browser, driver_path, click_timeout,
                ffmpeg_path, device_name, bitrate, do_split, split_prefix,
                silence_min, silence_pad, silence_thresh, silence_min_audio, silence_merge_gap):
    print(f"[run] URL={url}  duration={duration_sec}s  out={out_mp3}  browser={browser}")
    driver = open_and_start_play(url, browser=browser, driver_path=driver_path, click_timeout=click_timeout)
    try:
        time.sleep(1.0)
        ret = run_ffmpeg_record(device_name, out_mp3, duration_sec, ffmpeg_path, bitrate=bitrate)
        ok = (ret == 0 and os.path.exists(out_mp3) and os.path.getsize(out_mp3) > 0)
        print(f"[ffmpeg] exit={ret} ok={ok}")
        if ok and do_split:
            print("[split] 録音後のサイレンス自動分割を実行します…")
            try:
                n = split_on_silence_postproc(out_mp3, split_prefix, silence_min, silence_pad,
                                              silence_thresh, bitrate, silence_min_audio, silence_merge_gap)
                print(f"[split] segments={n}")
            except Exception as e:
                print("[warn] 分割処理でエラー:", e)
        return ok
    finally:
        close_driver_quiet(driver)

def main():
    ap = argparse.ArgumentParser(description="VoicyをSeleniumで再生→VB-CABLEでffmpeg録音→(任意)無音分割。TSV/タイトル正規表現/バッチ対応。")
    g_src = ap.add_mutually_exclusive_group(required=False)
    g_src.add_argument("--url", help="エピソードURLを直接指定（--duration-sec と --out が必要）")
    g_src.add_argument("--tsv", help="一覧TSV（ヘッダ付きを推奨）")

    ap.add_argument("--tsv-encoding", default="utf-8")
    ap.add_argument("--title-regex", default=r'^\s*#\s*\d+')
    ap.add_argument("--number", type=int)
    ap.add_argument("--range")

    ap.add_argument("--duration-sec", type=int)
    ap.add_argument("--out")
    ap.add_argument("--out-dir")

    ap.add_argument("--browser", choices=["chrome", "edge"], default="chrome")
    ap.add_argument("--driver-path")
    ap.add_argument("--click-timeout", type=float, default=10.0)

    ap.add_argument("--ffmpeg", default=FFMPEG_DEFAULT)
    ap.add_argument("--device", default=DEVICE_DEFAULT)
    ap.add_argument("--bitrate", default="192k")

    ap.add_argument("--split-on-silence", action="store_true")
    ap.add_argument("--split-prefix")
    ap.add_argument("--silence-min", type=float, default=5.0)
    ap.add_argument("--silence-pad", type=float, default=0.15)
    ap.add_argument("--silence-thresh", type=float, default=None)
    ap.add_argument("--silence-min-audio", type=float, default=1.0)
    ap.add_argument("--silence-merge-gap", type=float, default=0.5)

    ap.add_argument("--dry-run", action="store_true")

    args = ap.parse_args()

    jobs: List[Tuple[str, int, str]] = []

    if args.url:
        if args.duration_sec is None or not args.out:
            ap.error("--url を使う場合は --duration-sec と --out が必要です。")
        jobs.append((args.url, int(args.duration_sec), args.out))
    elif args.tsv:
        rows = load_tsv(args.tsv, encoding=args.tsv_encoding)
        picked = select_rows(rows, args.number, args.range, args.title_regex)
        if not picked:
            print("[error] TSVから対象が見つかりませんでした。", file=sys.stderr); sys.exit(2)
        for r in picked:
            try:
                number, title, url, duration_text, explicit_out = extract_fields(r)
            except Exception as e:
                print("[warn] スキップ（必須フィールド不足）:", e); continue
            if not duration_text:
                print(f"[warn] duration が無い行をスキップ: title={title}"); continue
            try:
                duration_sec = parse_duration_to_seconds(duration_text)
            except Exception as e:
                print(f"[warn] duration解析失敗のためスキップ: {duration_text} ({e})"); continue
            out_mp3 = build_out_path(args.out_dir, number, title, explicit_out)
            jobs.append((url, duration_sec, out_mp3))
    else:
        ap.error("--url か --tsv のいずれかを指定してください。")

    for (url, dur, outp) in jobs:
        print("="*72)
        print(f"[job] URL={url}")
        print(f"[job] duration={dur}s  out={outp}")
        if args.dry_run:
            print("[dry-run] 録音は行いません。"); continue
        ok = process_one(url, dur, outp,
                         browser=args.browser, driver_path=args.driver_path, click_timeout=args.click_timeout,
                         ffmpeg_path=args.ffmpeg, device_name=args.device, bitrate=args.bitrate,
                         do_split=args.split_on_silence, split_prefix=args.split_prefix,
                         silence_min=args.silence_min, silence_pad=args.silence_pad,
                         silence_thresh=args.silence_thresh, silence_min_audio=args.silence_min_audio,
                         silence_merge_gap=args.silence_merge_gap)
        if not ok:
            print("[warn] 失敗の可能性があります。ログをご確認ください。")

if __name__ == "__main__":
    if os.name != "nt":
        print("This script is intended for Windows.", file=sys.stderr)
    main()
